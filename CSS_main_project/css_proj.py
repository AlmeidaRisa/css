# -*- coding: utf-8 -*-
"""css_proj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lapSbcaXTCj-ibde1D1RdDabEcGXHOrR
"""

#!pip install numpy

#!pip install Pillow
#!pip install numpy
#!pip install opencv-python

from PIL import Image
import numpy as np
import time

# Define the encryption function
def encrypt_image(image, key):
    # Convert the image to a numpy array
    image_array = np.array(image)

    # Generate the chaotic sequence
    chaotic_sequence = generate_chaotic_sequence(key, image_array.size)

    # Normalize the chaotic sequence to fit within the range of integers
    max_val = np.max(image_array)
    min_val = np.min(image_array)
    chaotic_sequence = np.interp(chaotic_sequence, (np.min(chaotic_sequence), np.max(chaotic_sequence)), (min_val, max_val))

    # Convert the chaotic sequence to a numpy array
    chaotic_sequence_array = np.array(chaotic_sequence, dtype=image_array.dtype)

    # Reshape the chaotic sequence array to match the shape of the image array
    chaotic_sequence_array = np.reshape(chaotic_sequence_array, image_array.shape)

    # XOR the image array with the chaotic sequence
    encrypted_image = np.bitwise_xor(image_array, chaotic_sequence_array)

    # Convert the encrypted image back to a PIL Image object
    encrypted_image = Image.fromarray(encrypted_image)

    return encrypted_image

# Define the decryption function
def decrypt_image(encrypted_image, key):
    # Convert the encrypted image to a numpy array
    encrypted_image_array = np.array(encrypted_image)

    # Generate the chaotic sequence
    chaotic_sequence = generate_chaotic_sequence(key, encrypted_image_array.size)

    # Normalize the chaotic sequence to fit within the range of integers
    max_val = np.max(encrypted_image_array)
    min_val = np.min(encrypted_image_array)
    chaotic_sequence = np.interp(chaotic_sequence, (np.min(chaotic_sequence), np.max(chaotic_sequence)), (min_val, max_val))

    # Convert the chaotic sequence to a numpy array
    chaotic_sequence_array = np.array(chaotic_sequence, dtype=encrypted_image_array.dtype)

    # Reshape the chaotic sequence array to match the shape of the encrypted image array
    chaotic_sequence_array = np.reshape(chaotic_sequence_array, encrypted_image_array.shape)

    # XOR the encrypted image array with the chaotic sequence
    decrypted_image = np.bitwise_xor(encrypted_image_array, chaotic_sequence_array)

    # Convert the decrypted image back to a PIL Image object
    decrypted_image = Image.fromarray(decrypted_image)

    return decrypted_image

# Function to generate the chaotic sequence
def generate_chaotic_sequence(key, size=100):
    # Initialize the sequence with the key
    sequence = [key]

    # Iterate until the sequence reaches the desired size
    while len(sequence) < size:
        # Generate the next value in the sequence using the logistic map
        next_value = 4 * sequence[-1] * (1 - sequence[-1])
        sequence.append(next_value)

    return sequence

# Get the user input for the image
image_path = input("Enter the path to the image: ")

# Load the image
image = Image.open(image_path)

# Get the user input for the key
key = float(input("Enter the key: "))

# Start the timer
start_time = time.time()

# Encrypt the image
encrypted_image = encrypt_image(image, key)

# Decrypt the image
decrypted_image = decrypt_image(encrypted_image, key)

# End the timer
end_time = time.time()

# Calculate the execution time
execution_time = end_time - start_time
print("Execution time:", execution_time, "seconds")

# Save the encrypted image
encrypted_image.save("encrypted_image.png")

# Save the decrypted image
decrypted_image.save("decrypted_image.png")
